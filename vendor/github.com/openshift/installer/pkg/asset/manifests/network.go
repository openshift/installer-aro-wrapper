package manifests

import (
	"fmt"
	"path/filepath"

	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/yaml"

	configv1 "github.com/openshift/api/config/v1"
	operatorv1 "github.com/openshift/api/operator/v1"
	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/installconfig"
	"github.com/openshift/installer/pkg/asset/templates/content/openshift"
	"github.com/openshift/installer/pkg/types"
	"github.com/openshift/installer/pkg/types/aws"
	"github.com/openshift/installer/pkg/types/powervs"
)

var (
	noCrdFilename  = filepath.Join(manifestDir, "cluster-network-01-crd.yml")
	noCfgFilename  = filepath.Join(manifestDir, "cluster-network-02-config.yml")
	cnoCfgFilename = filepath.Join(manifestDir, "cluster-network-03-config.yml")
	// Cluster Network MTU for AWS Local Zone deployments on edge machine pools.
	ovnKNetworkMtuEdge   uint32 = 1200
	ocpSDNNetworkMtuEdge uint32 = 1250
)

// We need to manually create our CRDs first, so we can create the
// configuration instance of it in the installer. Other operators have
// their CRD created by the CVO, but we need to create the corresponding
// CRs in the installer, so we need the CRD to be there.
// The first CRD is the high-level Network.config.openshift.io object,
// which is stable and minimal. Administrators can configure the
// network in a more detailed manner with the operator-specific CR, which
// also needs to be done before the installer is run, so we provide both.

// Networking generates the cluster-network-*.yml files.
type Networking struct {
	Config   *configv1.Network
	FileList []*asset.File
}

var _ asset.WritableAsset = (*Networking)(nil)

// Name returns a human friendly name for the operator.
func (no *Networking) Name() string {
	return "Network Config"
}

// Dependencies returns all of the dependencies directly needed to generate
// network configuration.
func (no *Networking) Dependencies() []asset.Asset {
	return []asset.Asset{
		&installconfig.InstallConfig{},
		&openshift.NetworkCRDs{},
	}
}

// Generate generates the network operator config and its CRD.
func (no *Networking) Generate(dependencies asset.Parents) error {
	installConfig := &installconfig.InstallConfig{}
	crds := &openshift.NetworkCRDs{}
	dependencies.Get(installConfig, crds)

	netConfig := installConfig.Config.Networking

	clusterNet := []configv1.ClusterNetworkEntry{}
	if len(netConfig.ClusterNetwork) > 0 {
		for _, net := range netConfig.ClusterNetwork {
			clusterNet = append(clusterNet, configv1.ClusterNetworkEntry{
				CIDR:       net.CIDR.String(),
				HostPrefix: uint32(net.HostPrefix),
			})
		}
	} else {
		return errors.Errorf("ClusterNetworks must be specified")
	}

	serviceNet := []string{}
	for _, sn := range netConfig.ServiceNetwork {
		serviceNet = append(serviceNet, sn.String())
	}

	no.Config = &configv1.Network{
		TypeMeta: metav1.TypeMeta{
			APIVersion: configv1.SchemeGroupVersion.String(),
			Kind:       "Network",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: "cluster",
			// not namespaced
		},
		Spec: configv1.NetworkSpec{
			ClusterNetwork: clusterNet,
			ServiceNetwork: serviceNet,
			NetworkType:    netConfig.NetworkType,
			// Block all Service.ExternalIPs by default
			ExternalIP: &configv1.ExternalIPConfig{
				Policy: &configv1.ExternalIPPolicy{},
			},
		},
	}

	configData, err := yaml.Marshal(no.Config)
	if err != nil {
		return errors.Wrapf(err, "failed to create %s manifests from InstallConfig", no.Name())
	}

	crdContents := ""
	for _, crdFile := range crds.Files() {
		crdContents = fmt.Sprintf("%s\n---\n%s", crdContents, crdFile.Data)
	}

	no.FileList = []*asset.File{
		{
			Filename: noCrdFilename,
			Data:     []byte(crdContents),
		},
		{
			Filename: noCfgFilename,
			Data:     configData,
		},
	}

	switch installConfig.Config.Platform.Name() {
	case aws.Name:
		cnoDefCfg, exists, err := no.generateDefaultNetworkConfigAWSEdge(installConfig)
		if err != nil {
			return err
		}
		if exists {
			no.FileList = append(no.FileList, &asset.File{
				Filename: cnoCfgFilename,
				Data:     cnoDefCfg,
			})
		}

	case powervs.Name:
		if netConfig.NetworkType == "OVNKubernetes" {
			ovnConfig, err := OvnKubeConfig(clusterNet, serviceNet, true)
			if err != nil {
				return errors.Wrapf(err, "cannot marshal Power VS OVNKube Config")
			}
			no.FileList = append(no.FileList, &asset.File{
				Filename: cnoCfgFilename,
				Data:     ovnConfig,
			})
		}

	}

	return nil
}

// Files returns the files generated by the asset.
func (no *Networking) Files() []*asset.File {
	return no.FileList
}

// Load returns false since this asset is not written to disk by the installer.
func (no *Networking) Load(f asset.FileFetcher) (bool, error) {
	return false, nil
}

// Generates the defaultNetwork for Cluster Network Operator configuration.
// The defaultNetwork is the "default" network that all pods will receive.
func (no *Networking) generateDefaultNetworkConfig(defaultNetwork *operatorv1.DefaultNetworkDefinition) ([]byte, error) {
	dnConfig := operatorv1.Network{
		TypeMeta: metav1.TypeMeta{
			APIVersion: operatorv1.SchemeGroupVersion.String(),
			Kind:       "Network",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: "cluster",
		},
		Spec: operatorv1.NetworkSpec{
			OperatorSpec:   operatorv1.OperatorSpec{ManagementState: operatorv1.Managed},
			DefaultNetwork: *defaultNetwork,
		},
	}

	return yaml.Marshal(dnConfig)
}

// Check if there is any edge machine pool created, and generate the
// CNO object to set DefaultNetwork for CNI with custom MTU.
// EC2 on AWS Local Zones  requires MTU 1300 to communicate with regular zones.
// The const (?)NetworkMtuEdge decreases from network plugin overhead.
// https://docs.aws.amazon.com/local-zones/latest/ug/how-local-zones-work.html
func (no *Networking) generateDefaultNetworkConfigAWSEdge(ic *installconfig.InstallConfig) ([]byte, bool, error) {
	var (
		hasEdgePool = false
		defNetCfg   *operatorv1.DefaultNetworkDefinition
		err         error
	)

	netConfig := ic.Config.Networking

	// Setup defaultNetwork only for Edge deployment on AWS
	for _, mp := range ic.Config.Compute {
		if mp.Name == types.MachinePoolEdgeRoleName {
			hasEdgePool = true
		}
	}
	if !hasEdgePool {
		return nil, false, nil
	}

	switch netConfig.NetworkType {
	case string(operatorv1.NetworkTypeOVNKubernetes):
		defNetCfg = &operatorv1.DefaultNetworkDefinition{
			Type: operatorv1.NetworkTypeOVNKubernetes,
			OVNKubernetesConfig: &operatorv1.OVNKubernetesConfig{
				MTU: &ovnKNetworkMtuEdge,
			},
		}

	case string(operatorv1.NetworkTypeOpenShiftSDN):
		defNetCfg = &operatorv1.DefaultNetworkDefinition{
			Type: operatorv1.NetworkTypeOpenShiftSDN,
			OpenShiftSDNConfig: &operatorv1.OpenShiftSDNConfig{
				MTU: &ocpSDNNetworkMtuEdge,
			},
		}
	default:
		return nil, true, errors.Wrapf(err, "unable to set the DefaultNetworkConfig for %s", netConfig.NetworkType)
	}

	cnoConfig, err := no.generateDefaultNetworkConfig(defNetCfg)
	if err != nil {
		return nil, true, errors.Wrapf(err, "cannot marshal DefaultNetworkConfig for %s", netConfig.NetworkType)
	}

	return cnoConfig, true, nil
}
